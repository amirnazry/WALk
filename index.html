<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Walky Talky</title>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <style>
    body { margin: 0; padding: 2rem 1rem; background: #000; color: #FFD700; font-family: 'Courier New', monospace; text-align: center; min-height: 100vh; display: flex; flex-direction: column; justify-content: center; }
    h1 { font-size: 2.5rem; margin: 0 0 1rem; text-shadow: 0 0 10px #FFD700; }
    p { font-size: 1rem; margin: 0.5rem 0; }
    #roomLink { background: #333; padding: 0.5rem; border-radius: 5px; word-break: break-all; font-family: monospace; }
    #talkBtn { background: #FFD700; color: #000; border: none; border-radius: 50%; width: 120px; height: 120px; font-size: 3rem; cursor: pointer; box-shadow: 0 0 20px #FFD700; transition: all 0.1s; margin: 2rem 0; }
    #talkBtn:active, #talkBtn.hold { transform: scale(0.95); box-shadow: 0 0 40px #fff; background: #fff; }
    footer { margin-top: auto; font-size: 0.8rem; color: #666; }
    @media (max-width: 600px) { #talkBtn { width: 100px; height: 100px; font-size: 2.5rem; } h1 { font-size: 2rem; } }
  </style>
</head>
<body>
  <h1>Walky Talky</h1>
  <p id="status">Connecting...</p>
  <button id="talkBtn" title="Hold to talk" disabled>ðŸŽ¤</button>
  <p>Share this link with a friend. Hold spacebar or tap to talk. Release to listen.</p>
  <p id="roomLink">Generating room...</p>
  <audio id="remoteAudio" autoplay></audio>
  <footer>Made for quick chats. Over and out.</footer>

  <script>
    (async () => {
      const peer = new Peer();
      const talkBtn = document.getElementById('talkBtn');
      const status = document.getElementById('status');
      const roomLinkEl = document.getElementById('roomLink');
      const remoteAudio = document.getElementById('remoteAudio');
      let localStream, conn, sender, audioCtx, isHolding = false, myPeerId;

      // Audio context for sounds
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Get local stream early
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        status.textContent = 'Mic ready. Getting peer ID...';
      } catch (err) {
        status.textContent = 'Mic access denied. Enable to chat.';
        return;
      }

      // Check if joining (has ?id)
      const url = new URL(window.location);
      const providedId = url.searchParams.get('id');

      peer.on('open', (myId) => {
        myPeerId = myId;
        if (providedId) {
          // Joiner: Use provided ID to call
          status.textContent = `Joining room...`;
          conn = peer.call(providedId, localStream);
          setupConnection(conn);
          roomLinkEl.textContent = window.location.href; // Already has ?id
        } else {
          // Host: Use myId as room, update URL
          url.searchParams.set('id', myId);
          history.replaceState({}, '', url);
          roomLinkEl.textContent = window.location.href;
          status.textContent = `Room ready: ${myId.slice(0,8)}. Share link!`;
          talkBtn.disabled = false;
          // Wait for incoming calls
          peer.on('call', (incoming) => {
            conn = incoming;
            conn.answer(localStream);
            setupConnection(conn);
            status.textContent = 'Connected! Hold to talk.';
          });
        }
      });

      function setupConnection(connection) {
        sender = connection.peerConnection.getSenders().find(s => s.track?.kind === 'audio');
        connection.on('stream', (remoteStream) => {
          remoteAudio.srcObject = remoteStream;
          talkBtn.disabled = false;
          status.textContent = 'Connected! Hold to talk.';
        });
      }

      // Hold to talk
      function startTalk() {
        if (!sender || isHolding || talkBtn.disabled) return;
        isHolding = true;
        talkBtn.classList.add('hold');
        sender.track.enabled = true;
        playBeep();
      }
      function stopTalk() {
        if (!isHolding) return;
        isHolding = false;
        talkBtn.classList.remove('hold');
        sender.track.enabled = false;
        playStatic();
      }

      // Events (enable after connection)
      talkBtn.addEventListener('mousedown', startTalk);
      talkBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startTalk(); });
      document.addEventListener('mouseup', stopTalk);
      document.addEventListener('touchend', stopTalk);
      document.addEventListener('keydown', (e) => { if (e.code === 'Space') { e.preventDefault(); startTalk(); } });
      document.addEventListener('keyup', (e) => { if (e.code === 'Space') stopTalk(); });

      // Sounds
      function playBeep() {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.frequency.value = 800;
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
      }
      function playStatic() {
        const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.1, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        const gain = audioCtx.createGain();
        source.connect(gain).connect(audioCtx.destination);
        gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
        source.start();
        source.stop(audioCtx.currentTime + 0.1);
      }
    })();
  </script>
</body>
</html>
